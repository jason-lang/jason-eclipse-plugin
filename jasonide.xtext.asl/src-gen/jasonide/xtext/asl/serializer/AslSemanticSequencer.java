/*
 * generated by Xtext 2.23.0
 */
package jasonide.xtext.asl.serializer;

import com.google.inject.Inject;
import jasonide.xtext.asl.asl.Agent;
import jasonide.xtext.asl.asl.Arithm_expr;
import jasonide.xtext.asl.asl.Arithm_expr_factor;
import jasonide.xtext.asl.asl.Arithm_expr_simple;
import jasonide.xtext.asl.asl.Arithm_expr_trm;
import jasonide.xtext.asl.asl.AslPackage;
import jasonide.xtext.asl.asl.Belief;
import jasonide.xtext.asl.asl.Body_formula;
import jasonide.xtext.asl.asl.Directive;
import jasonide.xtext.asl.asl.Function;
import jasonide.xtext.asl.asl.Initial_goal;
import jasonide.xtext.asl.asl.List;
import jasonide.xtext.asl.asl.Literal;
import jasonide.xtext.asl.asl.Log_expr;
import jasonide.xtext.asl.asl.Log_expr_factor;
import jasonide.xtext.asl.asl.Log_expr_trm;
import jasonide.xtext.asl.asl.Plan;
import jasonide.xtext.asl.asl.Plan_body;
import jasonide.xtext.asl.asl.Plan_body_factor;
import jasonide.xtext.asl.asl.Plan_body_term;
import jasonide.xtext.asl.asl.Plan_term;
import jasonide.xtext.asl.asl.Pred;
import jasonide.xtext.asl.asl.Rel_expr;
import jasonide.xtext.asl.asl.StmtFOR;
import jasonide.xtext.asl.asl.StmtIF;
import jasonide.xtext.asl.asl.StmtIFCommon;
import jasonide.xtext.asl.asl.StmtWHILE;
import jasonide.xtext.asl.asl.Term;
import jasonide.xtext.asl.asl.Term_in_list;
import jasonide.xtext.asl.asl.Terms;
import jasonide.xtext.asl.asl.Trigger;
import jasonide.xtext.asl.asl.Var;
import jasonide.xtext.asl.services.AslGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class AslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private AslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == AslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case AslPackage.AGENT:
				sequence_Agent(context, (Agent) semanticObject); 
				return; 
			case AslPackage.ARITHM_EXPR:
				sequence_Arithm_expr(context, (Arithm_expr) semanticObject); 
				return; 
			case AslPackage.ARITHM_EXPR_FACTOR:
				sequence_Arithm_expr_factor(context, (Arithm_expr_factor) semanticObject); 
				return; 
			case AslPackage.ARITHM_EXPR_SIMPLE:
				sequence_Arithm_expr_simple(context, (Arithm_expr_simple) semanticObject); 
				return; 
			case AslPackage.ARITHM_EXPR_TRM:
				sequence_Arithm_expr_trm(context, (Arithm_expr_trm) semanticObject); 
				return; 
			case AslPackage.BELIEF:
				sequence_Belief(context, (Belief) semanticObject); 
				return; 
			case AslPackage.BODY_FORMULA:
				sequence_Body_formula(context, (Body_formula) semanticObject); 
				return; 
			case AslPackage.DIRECTIVE:
				sequence_Directive(context, (Directive) semanticObject); 
				return; 
			case AslPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case AslPackage.INITIAL_GOAL:
				sequence_Initial_goal(context, (Initial_goal) semanticObject); 
				return; 
			case AslPackage.LIST:
				sequence_List(context, (List) semanticObject); 
				return; 
			case AslPackage.LITERAL:
				sequence_Literal(context, (Literal) semanticObject); 
				return; 
			case AslPackage.LOG_EXPR:
				sequence_Log_expr(context, (Log_expr) semanticObject); 
				return; 
			case AslPackage.LOG_EXPR_FACTOR:
				sequence_Log_expr_factor(context, (Log_expr_factor) semanticObject); 
				return; 
			case AslPackage.LOG_EXPR_TRM:
				sequence_Log_expr_trm(context, (Log_expr_trm) semanticObject); 
				return; 
			case AslPackage.NUMBER:
				sequence_Number(context, (jasonide.xtext.asl.asl.Number) semanticObject); 
				return; 
			case AslPackage.PLAN:
				sequence_Plan(context, (Plan) semanticObject); 
				return; 
			case AslPackage.PLAN_BODY:
				sequence_Plan_body(context, (Plan_body) semanticObject); 
				return; 
			case AslPackage.PLAN_BODY_FACTOR:
				sequence_Plan_body_factor(context, (Plan_body_factor) semanticObject); 
				return; 
			case AslPackage.PLAN_BODY_TERM:
				sequence_Plan_body_term(context, (Plan_body_term) semanticObject); 
				return; 
			case AslPackage.PLAN_TERM:
				sequence_Plan_term(context, (Plan_term) semanticObject); 
				return; 
			case AslPackage.PRED:
				sequence_Pred(context, (Pred) semanticObject); 
				return; 
			case AslPackage.REL_EXPR:
				sequence_Rel_expr(context, (Rel_expr) semanticObject); 
				return; 
			case AslPackage.STMT_FOR:
				sequence_StmtFOR(context, (StmtFOR) semanticObject); 
				return; 
			case AslPackage.STMT_IF:
				sequence_StmtIF(context, (StmtIF) semanticObject); 
				return; 
			case AslPackage.STMT_IF_COMMON:
				sequence_StmtIFCommon(context, (StmtIFCommon) semanticObject); 
				return; 
			case AslPackage.STMT_WHILE:
				sequence_StmtWHILE(context, (StmtWHILE) semanticObject); 
				return; 
			case AslPackage.STRING:
				sequence_String(context, (jasonide.xtext.asl.asl.String) semanticObject); 
				return; 
			case AslPackage.TERM:
				sequence_Term(context, (Term) semanticObject); 
				return; 
			case AslPackage.TERM_IN_LIST:
				sequence_Term_in_list(context, (Term_in_list) semanticObject); 
				return; 
			case AslPackage.TERMS:
				sequence_Terms(context, (Terms) semanticObject); 
				return; 
			case AslPackage.TRIGGER:
				sequence_Trigger(context, (Trigger) semanticObject); 
				return; 
			case AslPackage.VAR:
				sequence_Var(context, (Var) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Agent returns Agent
	 *
	 * Constraint:
	 *     (
	 *         directive+=Directive+ | 
	 *         (directive+=Directive+ (plan+=Plan belief+=Belief* directive+=Directive*)*) | 
	 *         (
	 *             (
	 *                 (directive+=Directive+ (belief+=Belief directive+=Directive*)+ (initial_goal+=Initial_goal directive+=Directive*)*) | 
	 *                 (directive+=Directive+ (initial_goal+=Initial_goal directive+=Directive*)*)
	 *             ) 
	 *             (plan+=Plan belief+=Belief* directive+=Directive*)*
	 *         )
	 *     )?
	 */
	protected void sequence_Agent(ISerializationContext context, Agent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Arithm_expr returns Arithm_expr
	 *
	 * Constraint:
	 *     (arithm_expr_trm=Arithm_expr_trm (subadd=TK_SUB_ADD arithm_expr=Arithm_expr)?)
	 */
	protected void sequence_Arithm_expr(ISerializationContext context, Arithm_expr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Arithm_expr_factor returns Arithm_expr_factor
	 *
	 * Constraint:
	 *     (arithm_expr_simple=Arithm_expr_simple (exponential=TK_EXPONENTIAL arithm_expr_factor=Arithm_expr_factor)?)
	 */
	protected void sequence_Arithm_expr_factor(ISerializationContext context, Arithm_expr_factor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Arithm_expr_simple returns Arithm_expr_simple
	 *
	 * Constraint:
	 *     (number=Number | (unary=TK_UNARY_OP arithm_expr_simple=Arithm_expr_simple) | log_expr=Log_expr | function=Function)
	 */
	protected void sequence_Arithm_expr_simple(ISerializationContext context, Arithm_expr_simple semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Arithm_expr_trm returns Arithm_expr_trm
	 *
	 * Constraint:
	 *     (arithm_expr_factor=Arithm_expr_factor ((muldiv=TK_MUL_DIV | tk_intdiv=TK_INTDIV | tk_intmod=TK_INTMOD) arithm_expr_trm=Arithm_expr_trm)?)
	 */
	protected void sequence_Arithm_expr_trm(ISerializationContext context, Arithm_expr_trm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Belief returns Belief
	 *
	 * Constraint:
	 *     (literal=Literal log_expr=Log_expr?)
	 */
	protected void sequence_Belief(ISerializationContext context, Belief semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Body_formula returns Body_formula
	 *
	 * Constraint:
	 *     (plan_term=Plan_term | log_expr=Log_expr)
	 */
	protected void sequence_Body_formula(ISerializationContext context, Body_formula semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Directive returns Directive
	 *
	 * Constraint:
	 *     ((tk_begin=TK_BEGIN pred=Pred agent=Agent) | pred2=Pred)
	 */
	protected void sequence_Directive(ISerializationContext context, Directive semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Function returns Function
	 *
	 * Constraint:
	 *     literal=Literal
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AslPackage.Literals.FUNCTION__LITERAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AslPackage.Literals.FUNCTION__LITERAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionAccess().getLiteralLiteralParserRuleCall_0(), semanticObject.getLiteral());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Initial_goal returns Initial_goal
	 *
	 * Constraint:
	 *     literal=Literal
	 */
	protected void sequence_Initial_goal(ISerializationContext context, Initial_goal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AslPackage.Literals.INITIAL_GOAL__LITERAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AslPackage.Literals.INITIAL_GOAL__LITERAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInitial_goalAccess().getLiteralLiteralParserRuleCall_1_0(), semanticObject.getLiteral());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     List returns List
	 *
	 * Constraint:
	 *     (term_in_list+=Term_in_list term_in_list+=Term_in_list* (var=VART | unnamedvar=UNNAMEDVART | list=List)?)?
	 */
	protected void sequence_List(ISerializationContext context, List semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns Literal
	 *
	 * Constraint:
	 *     (((atom=JASON_ATOM | var=Var)? tk_neg=TK_NEG? (pred=Pred | var2=Var)) | tk_true=TK_TRUE | tk_false=TK_FALSE)
	 */
	protected void sequence_Literal(ISerializationContext context, Literal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Log_expr returns Log_expr
	 *
	 * Constraint:
	 *     (log_expr_trm=Log_expr_trm log_expr=Log_expr?)
	 */
	protected void sequence_Log_expr(ISerializationContext context, Log_expr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Log_expr_factor returns Log_expr_factor
	 *
	 * Constraint:
	 *     ((tk_not=TK_NOT log_expr_factor=Log_expr_factor) | rel_expr=Rel_expr)
	 */
	protected void sequence_Log_expr_factor(ISerializationContext context, Log_expr_factor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Log_expr_trm returns Log_expr_trm
	 *
	 * Constraint:
	 *     (log_expr_factor=Log_expr_factor log_expr_trm=Log_expr_trm?)
	 */
	protected void sequence_Log_expr_trm(ISerializationContext context, Log_expr_trm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Number returns Number
	 *
	 * Constraint:
	 *     ((number+=NUMBERT+ decimalPart+=NUMBERT+) | decimalPart+=NUMBERT+ | number+=NUMBERT+)
	 */
	protected void sequence_Number(ISerializationContext context, jasonide.xtext.asl.asl.Number semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Plan returns Plan
	 *
	 * Constraint:
	 *     ((tk_label_at=TK_LABEL_AT (literal=Literal | list=List))? trigger=Trigger log_expr=Log_expr? plan_body=Plan_body?)
	 */
	protected void sequence_Plan(ISerializationContext context, Plan semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Plan_body returns Plan_body
	 *
	 * Constraint:
	 *     (plan_body_term=Plan_body_term plan_body=Plan_body?)
	 */
	protected void sequence_Plan_body(ISerializationContext context, Plan_body semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Plan_body_factor returns Plan_body_factor
	 *
	 * Constraint:
	 *     ((stmtIF=StmtIF | stmtFOR=StmtFOR | stmtWHILE=StmtWHILE | body_formula=Body_formula) plan_body_factor=Plan_body_factor?)
	 */
	protected void sequence_Plan_body_factor(ISerializationContext context, Plan_body_factor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Plan_body_term returns Plan_body_term
	 *
	 * Constraint:
	 *     (plan_body_factor=Plan_body_factor plan_body_term=Plan_body_term?)
	 */
	protected void sequence_Plan_body_term(ISerializationContext context, Plan_body_term semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Plan_term returns Plan_term
	 *
	 * Constraint:
	 *     (((tk_label_at=TK_LABEL_AT pred=Pred)? trigger=Trigger log_expr=Log_expr?)? (literal=Literal log_expr2=Log_expr)? plan_body=Plan_body?)
	 */
	protected void sequence_Plan_term(ISerializationContext context, Plan_term semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Pred returns Pred
	 *
	 * Constraint:
	 *     ((atom=JASON_ATOM | tk_begin=TK_BEGIN | tk_end=TK_END) terms=Terms? plan_term+=Plan_term* list=List?)
	 */
	protected void sequence_Pred(ISerializationContext context, Pred semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rel_expr returns Rel_expr
	 *
	 * Constraint:
	 *     ((arithm_exp=Arithm_expr | string=String) (relOp=TK_REL_OP (arithm_expr=Arithm_expr | string2=String | list=List | plan_term=Plan_term))?)
	 */
	protected void sequence_Rel_expr(ISerializationContext context, Rel_expr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StmtFOR returns StmtFOR
	 *
	 * Constraint:
	 *     (tk_for=TK_FOR log_expr=Log_expr plan_term=Plan_term)
	 */
	protected void sequence_StmtFOR(ISerializationContext context, StmtFOR semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AslPackage.Literals.STMT_FOR__TK_FOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AslPackage.Literals.STMT_FOR__TK_FOR));
			if (transientValues.isValueTransient(semanticObject, AslPackage.Literals.STMT_FOR__LOG_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AslPackage.Literals.STMT_FOR__LOG_EXPR));
			if (transientValues.isValueTransient(semanticObject, AslPackage.Literals.STMT_FOR__PLAN_TERM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AslPackage.Literals.STMT_FOR__PLAN_TERM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStmtFORAccess().getTk_forTK_FORParserRuleCall_0_0(), semanticObject.getTk_for());
		feeder.accept(grammarAccess.getStmtFORAccess().getLog_exprLog_exprParserRuleCall_2_0(), semanticObject.getLog_expr());
		feeder.accept(grammarAccess.getStmtFORAccess().getPlan_termPlan_termParserRuleCall_4_0(), semanticObject.getPlan_term());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StmtIFCommon returns StmtIFCommon
	 *
	 * Constraint:
	 *     (log_expr=Log_expr plan_term=Plan_term ((tk_elif=TK_ELIF stmtIFCommon=StmtIFCommon) | (tk_else=TK_ELSE plan_term2=Plan_term))?)
	 */
	protected void sequence_StmtIFCommon(ISerializationContext context, StmtIFCommon semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StmtIF returns StmtIF
	 *
	 * Constraint:
	 *     (tk_if=TK_IF stmtIFCommon=StmtIFCommon)
	 */
	protected void sequence_StmtIF(ISerializationContext context, StmtIF semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AslPackage.Literals.STMT_IF__TK_IF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AslPackage.Literals.STMT_IF__TK_IF));
			if (transientValues.isValueTransient(semanticObject, AslPackage.Literals.STMT_IF__STMT_IF_COMMON) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AslPackage.Literals.STMT_IF__STMT_IF_COMMON));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStmtIFAccess().getTk_ifTK_IFParserRuleCall_0_0(), semanticObject.getTk_if());
		feeder.accept(grammarAccess.getStmtIFAccess().getStmtIFCommonStmtIFCommonParserRuleCall_1_0(), semanticObject.getStmtIFCommon());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StmtWHILE returns StmtWHILE
	 *
	 * Constraint:
	 *     (tk_while=TK_WHILE log_expr=Log_expr plan_term=Plan_term)
	 */
	protected void sequence_StmtWHILE(ISerializationContext context, StmtWHILE semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AslPackage.Literals.STMT_WHILE__TK_WHILE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AslPackage.Literals.STMT_WHILE__TK_WHILE));
			if (transientValues.isValueTransient(semanticObject, AslPackage.Literals.STMT_WHILE__LOG_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AslPackage.Literals.STMT_WHILE__LOG_EXPR));
			if (transientValues.isValueTransient(semanticObject, AslPackage.Literals.STMT_WHILE__PLAN_TERM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AslPackage.Literals.STMT_WHILE__PLAN_TERM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStmtWHILEAccess().getTk_whileTK_WHILEParserRuleCall_0_0(), semanticObject.getTk_while());
		feeder.accept(grammarAccess.getStmtWHILEAccess().getLog_exprLog_exprParserRuleCall_2_0(), semanticObject.getLog_expr());
		feeder.accept(grammarAccess.getStmtWHILEAccess().getPlan_termPlan_termParserRuleCall_4_0(), semanticObject.getPlan_term());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     String returns String
	 *
	 * Constraint:
	 *     string=STRINGT
	 */
	protected void sequence_String(ISerializationContext context, jasonide.xtext.asl.asl.String semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AslPackage.Literals.STRING__STRING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AslPackage.Literals.STRING__STRING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringAccess().getStringSTRINGTTerminalRuleCall_0(), semanticObject.getString());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns Term
	 *
	 * Constraint:
	 *     (list=List | plan_term=Plan_term | log_expr=Log_expr)
	 */
	protected void sequence_Term(ISerializationContext context, Term semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term_in_list returns Term_in_list
	 *
	 * Constraint:
	 *     (list=List | arithm_expr=Arithm_expr | string=String | plan_term=Plan_term)
	 */
	protected void sequence_Term_in_list(ISerializationContext context, Term_in_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Terms returns Terms
	 *
	 * Constraint:
	 *     (term+=Term term+=Term*)
	 */
	protected void sequence_Terms(ISerializationContext context, Terms semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Trigger returns Trigger
	 *
	 * Constraint:
	 *     (trigger=TriggerSymbol (literal=Literal | var=Var))
	 */
	protected void sequence_Trigger(ISerializationContext context, Trigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Var returns Var
	 *
	 * Constraint:
	 *     ((var=VART | unnamedvar=UNNAMEDVART) list=List?)
	 */
	protected void sequence_Var(ISerializationContext context, Var semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
